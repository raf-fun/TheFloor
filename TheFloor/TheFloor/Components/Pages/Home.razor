@page "/"
@using TheFloor.Model
@rendermode InteractiveServer

@inject IJSRuntime JS


<PageTitle>Home</PageTitle>

@if (showLoadImages)
{
    <div>
        <button class="btn btn-primary" @onclick="LoadImages">Load Images</button>
        <button class="btn btn-primary" @onclick="LoadSavedCategories">Load Images From History</button>
    </div>
}

@if (categories == null || !categories.Any())
{
    <p>No folders selected.</p>
}
else
{
    <div>
        <button class="btn btn-secondary mb-3" @onclick="PickRandomCategory">Pick Random Challenger</button>
    </div>
    <h4>Selected Folders</h4>
    <div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 row-cols-xl-4 g-4">
        @foreach (var category in categories)
        {
            var isDisabled = isPickingRandom || !(enabledCategories.Contains(category) && category != ChallengerCategory);
            <div class="col">
                <div class="card h-100 @(category == ChallengerCategory ? "highlight" : "") @(isDisabled ? "disabled-card" : "")"
                     style="background-color: @category.BgColor;" @onclick="@(isDisabled ? null : () => ShowBack(category))">
                    <div class="card-body">
                        <h5 class="card-title">@category.Name</h5>
                    </div>
                </div>
            </div>
        }
    </div>
}

@if (selectedCategory != null)
{
    <div class="fullscreen">
        <Back category="selectedCategory" Close="HideBack" Challenger="ChallengerCategory"/>
    </div>
}


@code {
    private bool showLoadImages = true;

    private List<FolderData> selectedFolders = new();
    private FolderData selectedFolder;

    private List<Category> categories = new();
    private List<Category> enabledCategories = new();
    private List<Category> pickedCategories = new();

    private Category? selectedCategory;
    public Category ChallengerCategory {get; set;}

    private int highlightIndex = 0;
    private bool isPickingRandom = false;
    private const int selectionDuration = 1000;

    private const string LocalStorageKey = "categoriesState";

    private Random random = new();



    [JSInvokable]
    public async Task HandleRandom()
    {
        await PickRandomCategory();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            
        await JS.InvokeVoidAsync("keyHandler.initialize", DotNetObjectReference.Create(this));
        }
    }

    public async Task LoadImages()
    {
        try
        {
            Console.WriteLine("Picker called.");

            var folders = await JS.InvokeAsync<FolderData[]>("GetFolderFiles");
            if (folders != null)
            {
                Console.WriteLine($"Received {folders.Length} folders");
                selectedFolders = folders.ToList();

                var colors = new List<string> { "#FF5733", "#33FF57", "#3357FF", "#F033FF", "#FF33A1", "#33FFA1", "#FFA133", "#A1FF33" };

                categories = selectedFolders.Select((folder, index) => new Category
                    {
                        Name = System.IO.Path.GetFileName(folder.Path),
                        Images = folder.Files,
                        BgColor = colors[index % colors.Count]
                    }).ToList();

                Shuffle(categories);

                showLoadImages = false;
                enabledCategories = new List<Category>();
            }
            else
            {
                Console.WriteLine("No folders received");
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error picking folder: {ex.Message}");
        }
    }

    private void ShowBack(Category category)
    {
        selectedCategory = category;
    }

    private async Task HideBack()
    {
        if (selectedCategory != null)
        {
            ReplaceCategory(selectedCategory, ChallengerCategory);
            selectedCategory = null;
        }

        if (ChallengerCategory != null)
        {
            enabledCategories = GetAdjacentCategories(ChallengerCategory);
            StateHasChanged();
        }
        else
        {
            enabledCategories.Clear();
        }

        StateHasChanged();

        await SaveCategories();
    }

    private async Task PickRandomCategory()
    {
        if (isPickingRandom)
        {
            return;
        }

        if (pickedCategories.Count == categories.Distinct().ToList().Count)
        {
            pickedCategories.Clear();
        }

        var availableCategories = categories.Except(pickedCategories).ToList();

        isPickingRandom = true;

        try
        {
            int totalSteps = selectionDuration / 100;
            for (int i = 0; i < totalSteps; i++)
            {
                highlightIndex = random.Next(availableCategories.Count); //i % availableCategories.Count;
                ChallengerCategory = availableCategories[highlightIndex];
                StateHasChanged();
                await Task.Delay(100);
            }
            pickedCategories.Add(ChallengerCategory);

        }
        catch (TaskCanceledException)
        {
            // Handle task cancellation
        }
        finally
        {
            isPickingRandom = false;
            enabledCategories = GetAdjacentCategories(ChallengerCategory);
            StateHasChanged();

            await SaveCategories();
        }
    }

    private void ReplaceCategory(Category oldCategory, Category newCategory)
    {
        for (int i = 0; i < categories.Count; i++)
        {
            if (categories[i].Name == oldCategory.Name)
            {
                categories[i] = newCategory;
            }
        }
    }

    private List<Category> GetAdjacentCategories(Category category)
    {
        var adjacentCategories = new List<Category>();
        int rowCount = 4; // Columns per row

        // Find all indices of the challenger category
        var indices = categories.Select((cate, index) => new { cate, index })
                                .Where(pair => pair.cate.Name == category.Name)
                                .Select(pair => pair.index)
                                .ToList();

        foreach (var index in indices)
        {
            // Above
            if (index - rowCount >= 0)
                adjacentCategories.Add(categories[index - rowCount]);

            // Below
            if (index + rowCount < categories.Count)
                adjacentCategories.Add(categories[index + rowCount]);

            // Left
            if (index % rowCount != 0)
                adjacentCategories.Add(categories[index - 1]);

            // Right
            if (index % rowCount != rowCount - 1 && index + 1 < categories.Count)
                adjacentCategories.Add(categories[index + 1]);
        }

        // Remove duplicates and return
        return adjacentCategories.Distinct().ToList();
    }

    private void Shuffle<T>(IList<T> list)
    {
        int n = list.Count;
        while (n > 1)
        {
            n--;
            int k = random.Next(n + 1);
            T value = list[k];
            list[k] = list[n];
            list[n] = value;
        }
    }

    private async Task SaveCategories()
    {
        await JS.InvokeVoidAsync("saveCategories", LocalStorageKey, categories);
    }

    private async Task LoadSavedCategories()
    {
        var savedCategories = await JS.InvokeAsync<Category[]>("loadCategories", LocalStorageKey);
        if (savedCategories != null)
        {
            categories = savedCategories.ToList();
            showLoadImages = false;
        }
    }
}

<style>
    .highlight {
        outline: #4CAF50 solid 10px;
    }

    .disabled-card {
        pointer-events: none;
        opacity: 0.5;
    }
</style>
